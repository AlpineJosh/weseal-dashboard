import { sql } from "@repo/db";
import { bitSystemsDb } from "@repo/db/bit-systems";
import { db } from "@repo/db/client";
import { sageDb } from "@repo/db/sage";
import schema from "@repo/db/schema";

const STOCK_CODES = ["BOPZ056WH0280SQM", "PET029SL000SQM", "PA000WH011001200"];

type Movement = typeof schema.batchMovement.$inferInsert;

interface Transaction {
  id: number;
  component_id: string;
  quantity: number;
  reference: string | null;
  date: Date;
  reference_numeric: number | null;
  details: string | null;
  type: "correction" | "production" | "receipt" | "despatch";
  created_at: Date;
  last_modified: Date;
}

interface Component {
  id: string;
  bitSystemsId: number;
  transactions: Transaction[];
  batches: {
    id: number;
    remainingQuantity: number;
    entryDate: Date;
  }[];
  grns: {
    orderId: number;
    remainingQuantity: number;
    date: Date;
  }[];
  receipts: {
    orderId: number;
    batchId: number;
    quantity: number;
    receiptDate: Date;
  }[];
  gdns: {
    orderId: number;
    quantity: number;
    date: Date;
  }[];
  despatches: {
    orderId: number;
    batchId: number;
    quantity: number;
    despatchDate: Date;
  }[];
  bitSystemsBatches: {
    id: number;
    reference: string;
    date: Date;
  }[];
  productionJobs: {
    reference: string;
    outputs: {
      batchId: number;
      quantity: number;
    }[];
    inputs: {
      batchId: number;
      quantity: number;
    }[];
  }[];
}

export class Reset {
  salesDespatchIds = new Map<number, Map<Date, Promise<number>>>();
  purchaseReceiptIds = new Map<number, Map<Date, Promise<number>>>();
  productionJobIds = new Map<string, Map<Date, Promise<number>>>();

  components = new Map<string, Component>();
  movements: (typeof schema.batchMovement.$inferInsert)[] = [];

  async process() {
    console.log("Deleting all");
    await this._deleteAll();
    console.log("Fetching data");
    await this._fetchData();
    console.log("Processing components");
    await this._processComponents();
    console.log("Done");
  }

  async _deleteAll() {
    await db.execute(sql`
      TRUNCATE TABLE 
        public.batch_movement_correction,
        public.production_batch_input,
        public.production_batch_output,
        public.batch_movement,
        public.production_job,
        public.sales_despatch_item,
        public.sales_despatch,
        public.purchase_receipt_item,
        public.purchase_receipt,
        public.task_item,
        public.task,
        public.batch 
      RESTART IDENTITY;
    `);
  }

  async _fetchData() {
    await sageDb.query.STOCK_TRAN.findMany().then((transactions) =>
      transactions.forEach((t) => {
        if (!t.STOCK_CODE || !t.TYPE || !t.DATE) return;

        // Debug - only process a few stock codes
        if (!STOCK_CODES.includes(t.STOCK_CODE)) return;

        if (!this.components.has(t.STOCK_CODE)) return;

        this.components.set(t.STOCK_CODE, {
          id: t.STOCK_CODE,
          bitSystemsId: 0,
          batches: [],
          grns: [],
          receipts: [],
          gdns: [],
          despatches: [],
          bitSystemsBatches: [],
          productionJobs: [],
          transactions: [],
        });

        const component = this.components.get(t.STOCK_CODE);
        if (!component) return;

        let type: "correction" | "production" | "receipt" | "despatch" =
          "correction";
        if (t.TYPE.startsWith("M") || t.REFERENCE?.startsWith("BOM")) {
          type = "production";
        } else if (t.TYPE === "GI") {
          type = "receipt";
        } else if (t.TYPE === "GD") {
          type = "despatch";
        }

        component.transactions.push({
          id: t.TRAN_NUMBER,
          component_id: t.STOCK_CODE,
          quantity: t.QUANTITY ?? 0,
          date: t.DATE,
          reference: t.REFERENCE,
          reference_numeric: t.REFERENCE_NUMERIC,
          details: t.DETAILS,
          type,
          created_at: t.RECORD_CREATE_DATE ?? t.DATE,
          last_modified: t.RECORD_MODIFY_DATE ?? t.RECORD_CREATE_DATE ?? t.DATE,
        });
      }),
    );

    await sageDb.query.GRN_ITEM.findMany().then((items) => {
      items.forEach((i) => {
        if (!i.STOCK_CODE || !i.ORDER_NUMBER || !i.DATE || !i.QTY_RECEIVED)
          return;

        const component = this.components.get(i.STOCK_CODE);
        if (!component) return;

        component.grns.push({
          orderId: i.ORDER_NUMBER,
          remainingQuantity: i.QTY_RECEIVED,
          date: i.DATE,
        });
      });
    });

    await sageDb.query.GDN_ITEM.findMany().then((items) => {
      items.forEach((i) => {
        if (!i.STOCK_CODE || !i.ORDER_NUMBER || !i.DATE || !i.QTY_DESPATCHED)
          return;

        const component = this.components.get(i.STOCK_CODE);
        if (!component) return;

        component.gdns.push({
          orderId: i.ORDER_NUMBER,
          quantity: i.QTY_DESPATCHED,
          date: i.DATE,
        });
      });
    });

    await bitSystemsDb.query.stockItem.findMany().then((items) => {
      items.forEach((i) => {
        if (!i.Code) return;
        const component = this.components.get(i.Code);
        if (!component) return;

        component.bitSystemsId = i.pk_StockItem_ID;
      });
    });

    await bitSystemsDb.query.traceableItem.findMany().then((batches) => {
      batches.forEach((b) => {
        const component = Array.from(this.components.values()).find(
          (c) => c.bitSystemsId === b.fk_StockItem_ID,
        );
        if (!component || !b.DateTimeCreated || !b.IdentificationNo) return;

        component.bitSystemsBatches.push({
          id: b.pk_TraceableItem_ID,
          reference: b.IdentificationNo,
          date: b.DateTimeCreated,
        });
      });
    });
  }

  async _processComponents() {
    const promises = [];
    for (const component of this.components.values()) {
      promises.push(this._processComponent(component));
    }

    await Promise.all(promises);

    await this._insertMovements();
  }

  async _processComponent(component: Component) {
    for (const transaction of component.transactions) {
      if (transaction.type === "receipt") {
        const quantity = transaction.quantity;
        let grn = null;
        for (const item of component.grns) {
          if (
            item.remainingQuantity > 0 &&
            Math.abs(item.date.getTime() - transaction.date.getTime()) <
              1000 * 60 * 60 * 24 * 5
          ) {
            grn = item;
            break;
          }
        }

        if (grn) {
          if (!this.purchaseReceiptIds.has(grn.orderId)) {
            this.purchaseReceiptIds.set(grn.orderId, new Map());
          }

          const receiptIds = this.purchaseReceiptIds.get(grn.orderId);
          if (!receiptIds) {
            console.error("No receipt ids");
            continue;
          }

          if (!receiptIds.has(transaction.date)) {
            const receiptItem = db
              .insert(schema.purchaseReceipt)
              .values({
                orderId: grn.orderId,
                receiptDate: transaction.date,
              })
              .returning({ id: schema.purchaseReceipt.id })
              .then((r) => {
                if (r.length === 0) {
                  console.error("No receipt created");
                  throw new Error("No receipt created");
                }
                return r[0]?.id ?? 0;
              });

            receiptIds.set(transaction.date, receiptItem);
          }

          
          const movement = await this._createBatch(
            transaction.component_id,
            null,
            quantity,
            transaction.date,
            transaction.last_modified,
            transaction.created_at,
          );
          if (!movement) {
            console.error("No movement created");
            continue;
          }
          this.movements.push({
            ...movement,
            type: "receipt",
            date: transaction.date,
            locationId: 1,
          });
          const receiptId = receiptIds.get(transaction.date)?.then(id => {

          })
          ;

          component.receipts.push({
            orderId: order.orderId,
            batchId: movement.batchId,
            quantity,
            receiptDate: order.date,
          });
        } else {
          const moves = await this._createInMovements(
            transaction.component_id,
            transaction.type,
            transaction.date,
            quantity,
          );

          movements.push(
            ...moves.map((m) => {
              return {
                ...m,
                type: "receipt" as const,
                date: transaction.date,
                locationId: 1,
              };
            }),
          );
        }
      } else if (transaction.type === "despatch") {
        const movements = await this._createOutMovements(
          transaction.component_id,
          transaction.date,
          transaction.type,
          transaction.quantity,
        );

        let order = null;
        for (const salesOrder of component.gdns) {
          //TODO better search for orders (maybe sort by absolute time difference to transaction date)
          if (
            salesOrder.quantity > 0 &&
            Math.abs(salesOrder.date.getTime() - transaction.date.getTime()) <
              1000 * 60 * 60 * 24 * 5
          ) {
            order = salesOrder;
            break;
          }
        }

        if (order) {
          component.despatches.push(
            ...movements.map((m) => ({
              orderId: order.orderId,
              batchId: m.batchId,
              quantity: m.quantity,
              despatchDate: order.date,
            })),
          );
        }
      } else if (transaction.type === "production") {
        // Attempt to find matching batch in bit systems
        // Create batch
        // Create production job
        // Create batch movement
        // } else if (transaction.type === "production_output") {
        // Find batch
        // Find production job
        // Create batch movement
      } else {
        // Find batch
        // Create batch movement
      }

      await db.insert(schema.batchMovement).values(movements);
    }
  }

  async _processReceipt(transaction: Transaction) {
    const quantity = transaction.quantity;
    let grn = null;
    for (const item of component.grns) {
      if (
        item.remainingQuantity > 0 &&
        Math.abs(item.date.getTime() - transaction.date.getTime()) <
          1000 * 60 * 60 * 24 * 5
      ) {
        grn = item;
        break;
      }
    }

    if (grn) {
      if (!this.purchaseReceiptIds.has(grn.orderId)) {
        this.purchaseReceiptIds.set(grn.orderId, new Map());
      }

      const receiptIds = this.purchaseReceiptIds.get(grn.orderId);
      if (!receiptIds) {
        console.error("No receipt ids");
        continue;
      }

      if (!receiptIds.has(transaction.date)) {
        const receiptItem = db
          .insert(schema.purchaseReceipt)
          .values({
            orderId: grn.orderId,
            receiptDate: transaction.date,
          })
          .returning({ id: schema.purchaseReceipt.id })
          .then((r) => {
            if (r.length === 0) {
              console.error("No receipt created");
              throw new Error("No receipt created");
            }
            return r[0]?.id ?? 0;
          });

        receiptIds.set(transaction.date, receiptItem);
      }

      
      const movement = await this._createBatch(
        transaction.component_id,
        null,
        quantity,
        transaction.date,
        transaction.last_modified,
        transaction.created_at,
      );
      if (!movement) {
        console.error("No movement created");
        continue;
      }
      this.movements.push({
        ...movement,
        type: "receipt",
        date: transaction.date,
        locationId: 1,
      });
      const receiptId = receiptIds.get(transaction.date)?.then(id => {

      })
      ;

      component.receipts.push({
        orderId: order.orderId,
        batchId: movement.batchId,
        quantity,
        receiptDate: order.date,
      });
    } else {
      const moves = await this._createInMovements(
        transaction.component_id,
        transaction.type,
        transaction.date,
        quantity,
      );

      movements.push(
        ...moves.map((m) => {
          return {
            ...m,
            type: "receipt" as const,
            date: transaction.date,
            locationId: 1,
          };
        }),
      );
    }
  }

  _processDespatch(transaction: Transaction) {

  }

  _processProductionInput(transaction: Transaction) {

  }

  _processProductionOutput(transaction: Transaction) {

  }

  async _insertMovements() {}

  async _processOutgoingTransaction(
    componentId: string,
    date: Date,
    type: "despatch" | "production" | "correction",
    quantity: number,
  ): Promise<Movement[]> {
    const component = this.components.get(componentId);
    if (!component) return [];

    if (component.batches.length === 0) {
      await this._createBatch(
        componentId,
        null,
        0,
        new Date("2016-01-01"),
        new Date("2016-01-01"),
        new Date("2016-01-01"),
      );
    }

    const batches = [];

    for (const batch of component.batches) {
      if (batch.remainingQuantity > 0) {
        const quantityUsed = Math.min(batch.remainingQuantity, quantity);

        batches.push({
          batchId: batch.id,
          quantity: quantityUsed,
          date: date,
          locationId: 1,
          type,
        });
        quantity -= quantityUsed;
        batch.remainingQuantity -= quantityUsed;
      }
    }

    if (quantity > 0) {
      const batch = component.batches[0];

      if (!batch) {
        console.error("No batch to use");
        return [];
      }

      batches.push({
        batchId: batch.id,
        quantity,
        date: date,
        locationId: 1,
        type,
      });

      batch.remainingQuantity -= quantity;
    }

    return batches;
  }

  async _createInMovements(
    componentId: string,
    type: "despatch" | "production" | "correction",
    date: Date,
    quantity: number,
  ): Promise<Movement[]> {
    const component = this.components.get(componentId);
    if (!component) return [];

    if (component.batches.length === 0) {
      await this._createBatch(
        componentId,
        null,
        0,
        new Date("2016-01-01"),
        new Date("2016-01-01"),
        new Date("2016-01-01"),
      );
    }

    const batches = [];

    for (const batch of component.batches) {
      if (batch.remainingQuantity < 0) {
        const quantityUsed = Math.min(-batch.remainingQuantity, quantity);
        batches.push({
          batchId: batch.id,
          quantity: quantityUsed,
          date,
          locationId: 1,
          type,
        });
        quantity -= quantityUsed;
        batch.remainingQuantity += quantityUsed;
      }
    }

    if (quantity > 0) {
      const batch = component.batches[component.batches.length - 1];

      if (!batch) {
        console.error("No batch to add to");
        return [];
      }

      batches.push({
        batchId: batch.id,
        quantity,
        date,
        locationId: 1,
        type,
      });

      batch.remainingQuantity += quantity;
    }

    return batches;
  }

  async _createBatch(
    componentId: string,
    reference: string | null,
    quantity: number,
    entryDate: Date,
    lastModified: Date,
    createdAt: Date,
  ): Promise<Movement | undefined> {
    const batches = await db
      .insert(schema.batch)
      .values({
        componentId: componentId,
        entryDate: entryDate,
        batchReference: reference,
        createdAt: createdAt,
        lastModified: lastModified,
      })
      .returning({ id: schema.batch.id });
    const batch = batches[0];

    if (!batch) {
      console.error("No batch created");
      return;
    }

    const component = this.components.get(componentId);
    if (!component) return;

    component.batches.push({
      id: batch.id,
      remainingQuantity: quantity,
      entryDate: entryDate,
    });

    return {
      batchId: batch.id,
      quantity,
      date: entryDate,
      locationId: 1,
      type: "receipt",
    };
  }

  // async _createBatchMovement(
  //   batchId: number,
  //   quantity: number,
  //   type:
  //     | "correction"
  //     | "production_input"
  //     | "production_output"
  //     | "receipt"
  //     | "despatch",
  // ) {
  //   return await {};
  // }

  // async _createProductionJob(reference: string | null, quantity: number) {
  //   return await {};
  // }

  // async _createPurchaseReceipt(orderId: number, receiptDate: Date) {
  //   return await {};
  // }

  // async _createSalesDespatch(orderId: number, despatchDate: Date) {
  //   return await {};
  // }
}

export const resetInventory = async () => {
  console.log("Resetting inventory");
  const reset = new Reset();
  await reset.process();
};

//   console.log("Fetching transactions");

//   const transactions = await sageDb.query.STOCK_TRAN.findMany().then(
//     (transactions) =>
//       transactions.map((t) => {
//         let type = "correction";
//         if (t.TYPE?.startsWith("M") || t.REFERENCE?.startsWith("BOM")) {
//           type = "production";
//         } else if (t.TYPE === "GI") {
//           type = "receipt";
//         } else if (t.TYPE === "GD") {
//           type = "despatch";
//         }
//         return {
//           id: t.TRAN_NUMBER,
//           component_id: t.STOCK_CODE,
//           quantity: t.QUANTITY ?? 0,
//           date: t.DATE,
//           reference: t.REFERENCE,
//           reference_numeric: t.REFERENCE_NUMERIC,
//           type,
//           created_at: t.RECORD_CREATE_DATE ?? t.DATE,
//           last_modified: t.RECORD_MODIFY_DATE ?? t.RECORD_CREATE_DATE ?? t.DATE,
//           sales_order_id: undefined as number | undefined,
//           purchase_order_id: undefined as number | undefined,
//           batch_reference: undefined as string | undefined,
//           batch_id: undefined as number | undefined,
//           purchaseReceiptItemId: undefined as number | undefined,
//           salesDespatchItemId: undefined as number | undefined,
//         };
//       }),
//   );

//   console.log("Linking sales order items to transactions");

//   const sop_items = await sageDb.query.SOP_ITEM.findMany();
//   const gdnItems = await sageDb.query.GDN_ITEM.findMany();

//   transactions.forEach((t) => {
//     if (t.type === "despatch") {
//       const sop_item = sop_items.find(
//         (s) =>
//           s.STOCK_CODE === t.component_id &&
//           s.ORDER_NUMBER === t.reference_numeric &&
//           s.QTY_DELIVERED === -t.quantity &&
//           s.DELIVERY_DATE === t.date,
//       );
//       if (sop_item) {
//         t.sales_order_id = sop_item.ORDER_NUMBER ?? undefined;
//       } else {
//         const gdnItem = gdnItems.find(
//           (g) =>
//             g.STOCK_CODE === t.component_id &&
//             g.DATE === t.date &&
//             g.QTY_DESPATCHED === -t.quantity,
//         );
//         if (gdnItem) {
//           t.sales_order_id = gdnItem.ORDER_NUMBER ?? undefined;
//         } else {
//           t.type = "correction";
//         }
//       }
//     }
//   });

//   console.log("Linking purchase order items to transactions");

//   const pop_items = await sageDb.query.POP_ITEM.findMany();
//   const grnItems = await sageDb.query.GRN_ITEM.findMany();

//   transactions.forEach((t) => {
//     if (t.type === "receipt") {
//       const pop_item = pop_items.find(
//         (s) =>
//           s.STOCK_CODE === t.component_id &&
//           s.ORDER_NUMBER === t.reference_numeric &&
//           s.QTY_DELIVERED === t.quantity &&
//           s.DELIVERY_DATE === t.date,
//       );
//       if (pop_item) {
//         t.purchase_order_id = pop_item.ORDER_NUMBER ?? undefined;
//       } else {
//         const grnItem = grnItems.find(
//           (g) =>
//             g.STOCK_CODE === t.component_id &&
//             g.DATE === t.date &&
//             g.QTY_RECEIVED === t.quantity,
//         );
//         if (grnItem) {
//           t.purchase_order_id = grnItem.ORDER_NUMBER ?? undefined;
//         } else {
//           t.type = "correction";
//         }
//       }
//     }
//   });

//   console.log("Fetching traceable items");

//   const traceable_items = await bitSystemsDb
//     .select({
//       component_id: bitSystemsSchema.stockItem.Code,
//       batch_reference: bitSystemsSchema.traceableItem.IdentificationNo,
//       created_at: bitSystemsSchema.traceableItem.DateTimeCreated,
//     })
//     .from(bitSystemsSchema.traceableItem)
//     .leftJoin(
//       bitSystemsSchema.stockItem,
//       eq(
//         bitSystemsSchema.traceableItem.fk_StockItem_ID,
//         bitSystemsSchema.stockItem.pk_StockItem_ID,
//       ),
//     );

//   console.log("Linking traceable items to transactions");

//   transactions.forEach((t) => {
//     if (t.type === "production" && t.quantity > 0) {
//       const traceable_item = traceable_items.find(
//         (ti) =>
//           ti.component_id === t.component_id &&
//           ti.created_at &&
//           t.created_at &&
//           Math.abs(ti.created_at.getTime() - t.created_at.getTime()) <
//             1000 * 60,
//       );
//       if (traceable_item) {
//         t.batch_reference = traceable_item.batch_reference ?? undefined;
//       }
//     }
//   });

//   console.log("Creating batches");

//   const batches: {
//     batch_id: number;
//     component_id: string;
//     remaining: number;
//   }[] = [];

//   for (const t of transactions) {
//     if (t.quantity > 0) {
//       if (t.type === "production" || t.type === "receipt") {
//         const batch = {
//           reference:
//             (t.batch_reference ?? t.purchase_order_id)
//               ? "PO-" + t.purchase_order_id
//               : "",
//           componentId: t.component_id!,
//           entryDate: t.date!,
//           createdAt: t.created_at!,
//           lastModified: t.last_modified!,
//         };
//         const results = await db
//           .insert(schema.batch)
//           .values(batch)
//           .returning({ id: schema.batch.id });
//         t.batch_id = results[0]?.id;
//       } else {
//         const result = await db.query.batch.findFirst({
//           where: eq(schema.batch.componentId, t.component_id!),
//           orderBy: desc(schema.batch.lastModified),
//         });
//         if (result) {
//           t.batch_id = result.id;
//         } else {
//           const results = await db
//             .insert(schema.batch)
//             .values({
//               componentId: t.component_id!,
//               entryDate: t.date!,
//               createdAt: t.created_at!,
//               lastModified: t.last_modified!,
//             })
//             .returning({ id: schema.batch.id });
//           t.batch_id = results[0]?.id;
//         }
//       }
//     }
//   }

//   console.log("Creating batch movements");

//   const batch_movements = [];

//   for (const t of transactions) {
//     if (t.quantity === 0) continue;
//     if (t.quantity > 0) {
//       const batch = batches.find((b) => b.batch_id === t.batch_id);
//       if (batch) {
//         batch.remaining += t.quantity;
//       }
//       batch_movements.push({
//         batchId: t.batch_id!,
//         quantity: t.quantity,
//         date: t.date!,
//         type: t.type,
//         created_at: t.created_at,
//         last_modified: t.last_modified,
//       });
//     }
//     if (t.quantity < 0) {
//       const matching = batches.filter(
//         (b) => b.component_id === t.component_id && b.remaining > 0,
//       );
//       if (matching.length > 0) {
//         while (t.quantity < 0 && matching.length > 0) {
//           const batch = matching.shift();
//           if (batch) {
//             const quantityToMove = Math.min(-t.quantity, batch.remaining);

//             batch_movements.push({
//               batchId: batch.batch_id,
//               quantity: quantityToMove,
//               type: t.type,
//               date: t.date!,
//               created_at: t.created_at,
//               last_modified: t.last_modified,
//             });
//             batch.remaining -= quantityToMove;
//             t.quantity += quantityToMove;
//           }
//         }
//         if (t.quantity < 0) {
//           const batch = batches.find(
//             (b) => b.component_id === t.component_id && b.remaining > 0,
//           );
//           if (batch) {
//             batch_movements.push({
//               batchId: batch.batch_id,
//               quantity: -t.quantity,
//               type: t.type,
//               date: t.date!,
//               created_at: t.created_at,
//               last_modified: t.last_modified,
//             });
//             batch.remaining -= t.quantity;
//           }
//         }
//       }
//     }
//   }

//   console.log("Creating purchase receipts");

//   const purchaseReceiptItems = transactions.filter(
//     (t) => t.type === "receipt" && t.purchase_order_id,
//   );
//   const purchaseReceipts = new Set(
//     purchaseReceiptItems.map((t) => ({
//       orderId: t.purchase_order_id!,
//       receiptDate: t.date!,
//     })),
//   );
//   const receipts = [];

//   for (let i = 0; i < purchaseReceipts.size; i += 1000) {
//     const receiptsChunk = Array.from(purchaseReceipts).slice(i, i + 1000);
//     const results = await db
//       .insert(schema.purchaseReceipt)
//       .values(receiptsChunk)
//       .onConflictDoNothing()
//       .returning({
//         id: schema.purchaseReceipt.id,
//         date: schema.purchaseReceipt.receiptDate,
//         orderId: schema.purchaseReceipt.orderId,
//       });
//     receipts.push(...results);
//   }

//   console.log("Linking purchase receipts to items");

//   for (const r of purchaseReceiptItems) {
//     const receipt = receipts.find(
//       (r) => r.date === r.date && r.orderId === r.orderId,
//     );
//     if (receipt) {
//       const results = await db
//         .insert(schema.purchaseReceiptItem)
//         .values({
//           receiptId: receipt.id,
//           batchId: r.batch_id!,
//           quantity: r.quantity,
//           createdAt: r.created_at!,
//           lastModified: r.last_modified!,
//         })
//         .returning({ id: schema.purchaseReceiptItem.id });
//       r.purchaseReceiptItemId = results[0]?.id;
//     }
//   }

//   console.log("Creating sales despatches");

//   const salesDespatchItems = transactions.filter(
//     (t) => t.type === "despatch" && t.sales_order_id,
//   );
//   const salesDespatches = new Set(
//     salesDespatchItems.map((t) => ({
//       orderId: t.sales_order_id!,
//       receiptDate: t.date!,
//     })),
//   );
//   const despatches = [];

//   for (let i = 0; i < salesDespatches.size; i += 1000) {
//     const despatchesChunk = Array.from(salesDespatches).slice(i, i + 1000);
//     const results = await db
//       .insert(schema.salesDespatch)
//       .values(despatchesChunk)
//       .onConflictDoNothing()
//       .returning({
//         id: schema.salesDespatch.id,
//         date: schema.salesDespatch.despatchDate,
//         orderId: schema.salesDespatch.orderId,
//       });
//     despatches.push(...results);
//   }

//   console.log("Linking sales despatches to items");

//   for (const r of salesDespatchItems) {
//     const despatch = despatches.find(
//       (r) => r.date === r.date && r.orderId === r.orderId,
//     );
//     if (despatch) {
//       const results = await db
//         .insert(schema.salesDespatchItem)
//         .values({
//           despatchId: despatch.id,
//           batchId: r.batch_id!,
//           quantity: -r.quantity,
//           createdAt: r.created_at!,
//           lastModified: r.last_modified!,
//         })
//         .onConflictDoNothing()
//         .returning({ id: schema.salesDespatchItem.id });
//       r.salesDespatchItemId = results[0]?.id;
//     }
//   }

//   console.log("Saving batch movements");

//   for (let i = 0; i < batch_movements.length; i += 1000) {
//     const batch_movements_chunk = batch_movements
//       .slice(i, i + 1000)
//       .map((bm) => ({
//         batchId: bm.batchId,
//         quantity: bm.quantity,
//         date: bm.date,
//         type: bm.type as "correction" | "production" | "receipt" | "despatch",
//         locationId: 1,
//         userId: "1",
//         createdAt: bm.created_at!,
//         lastModified: bm.last_modified!,
//       }));
//     await db
//       .insert(schema.batchMovement)
//       .values(batch_movements_chunk)
//       .onConflictDoNothing();
//   }
// };
